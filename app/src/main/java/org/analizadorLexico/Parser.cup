package org.analizadorLexico;
import org.analizadorLexico.ast.*; // Importa todos los nodos
import java_cup.runtime.*;
import org.analizadorLexico.simbolos.*;

parser code {:
    public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    // Conectar el parser con el lexer
    public Parser(Lexer lexer) {
        super(lexer);
    }
:}

/* --- Declaracion de Terminales (Tokens) --- */

// Palabras reservadas
terminal WORLD, LOCAL, GIFT, NAVIDAD, COAL;
terminal DECIDE, OF, END, LOOP, EXIT, WHEN, FOR;
terminal SHOW, GET, RETURN, BREAK, ELSE, ENDL;

// Tipos de datos
terminal INT, FLOAT, BOOL, CHAR, STRING;

// Operadores y Signos
terminal BLOCK_START, BLOCK_END; // ¡, !
terminal PAREN_OPEN, PAREN_CLOSE; // ¿, ?
terminal COMMA, ARROW, SEMICOLON; // , , -> , ;
terminal LEFT_ARRAY, RIGHT_ARRAY; // [,]

// Aritmeticos
terminal PLUS, MINUS, MULT, DIV, DIV_INT, MOD, POWER;
terminal INC, DEC;

// Relacionales y Logicos
terminal ASSIGN; // =
terminal EQ_EQ, NOT_EQ, LESS, GREATER, LESS_EQ, GREATER_EQ;
terminal AND, OR, NOT; // @, ~, Σ

// Terminales con valor (Lexema)
terminal String IDENTIFIER;
terminal String LIT_STRING;
terminal String LIT_CHAR;
terminal Integer LIT_INT;
terminal Double LIT_FLOAT;
terminal Boolean LIT_BOOL;

/* --- Seccion de No Terminales (Gramatica) --- */

non terminal Program program;
non terminal Declaration_list_node declaration_list;
non terminal NodoAST declaration;
non terminal Global_var_decl_node global_var;
non terminal Param_list_node param_list;
non terminal Param_list_node params_items;
non terminal Param_node param;
non terminal Main_def_node main_def;
non terminal Block_node block;
non terminal Statement_list_node statement_list;
non terminal Function_def_node function_def;
non terminal TypeNode type;
non terminal Dims_decl_node dims_decl;
non terminal Array_init_node array_init;
non terminal Row_list_node row_list;
non terminal Var_decl_node var_decl;
non terminal Array_row_node array_node;
non terminal If_statement_node if_statement;
non terminal Case_list_node case_list;
non terminal Single_case_node single_case;
non terminal Else_part_node else_part;
non terminal Loop_statement_node loop_statement;
non terminal NodoAST statement;
non terminal For_statement_node for_statement;
non terminal Io_statement_node io_statement;
non terminal Break_statement_node break_statement;
non terminal Return_statement_node return_statement;
non terminal Func_call_node func_call;
non terminal Assignment_node assignment;
non terminal NodoAST expression;
non terminal Expression_list_node expression_list;
non terminal Array_row_node array_row;



precedence left OR;
precedence left AND;
precedence left EQ_EQ, NOT_EQ;
precedence left LESS, LESS_EQ, GREATER, GREATER_EQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, DIV_INT, MOD;
precedence right POWER;
precedence right NOT, INC, DEC;
precedence left PAREN_OPEN, PAREN_CLOSE;

/* --- Gramática --- */

start with program;

program ::= declaration_list:lista{: RESULT = new Program(lista); :};

declaration_list ::= declaration_list:lista declaration:decl {: lista.agregarHijo(decl); RESULT = lista; :}
                   | declaration:decl {: Declaration_list_node nuevaLista = new Declaration_list_node(); nuevaLista.agregarHijo(decl); RESULT = nuevaLista; :};

declaration ::= global_var:global {: RESULT = global; :}
              | function_def:func {: RESULT = func; :}
              | main_def:main {: RESULT = main; :};

global_var ::= WORLD type:t IDENTIFIER:id ENDL {: RESULT = new Global_var_decl_node(t, id); parser.tablaSimbolos.agregar(id, t.getNombreTipo()); :}
             | WORLD type:t IDENTIFIER:id ASSIGN expression:expr ENDL {: RESULT = new Global_var_decl_node(t, id, expr); parser.tablaSimbolos.agregar(id, t.getNombreTipo()); :}
             | WORLD type:t IDENTIFIER:id dims_decl:d ENDL {: RESULT = new Global_var_decl_node(t, id, d, null); parser.tablaSimbolos.agregar(id, t.getNombreTipo()+"[]"); :}
             | WORLD type:t IDENTIFIER:id dims_decl:d ASSIGN array_init:ai ENDL {: RESULT = new Global_var_decl_node(t, id, d, ai); parser.tablaSimbolos.agregar(id, t.getNombreTipo()+"[]"); :};

function_def ::= GIFT type:t IDENTIFIER:id PAREN_OPEN param_list:params PAREN_CLOSE block:b {: RESULT = new Function_def_node(t, id, params, b); :};

param_list ::= params_items:params_items {: RESULT = params_items; :}
             | /* vacio */ {: RESULT = new Param_list_node(); :} ;

params_items ::= params_items:lista COMMA param:param {: lista.agregarHijo(param); RESULT = lista; :}
               | param:param {: Param_list_node p = new Param_list_node(); p.agregarHijo(param); RESULT = p; :} ;

param ::= type:t IDENTIFIER:id {: RESULT = new Param_node(t, id); :};

main_def ::= COAL NAVIDAD PAREN_OPEN PAREN_CLOSE block:b {: RESULT = new Main_def_node(b); :};

block ::= BLOCK_START statement_list:lista BLOCK_END {: RESULT = new Block_node(lista); :}
        | BLOCK_START BLOCK_END {: RESULT = new Block_node(); :};

type ::= INT {: RESULT = new TypeNode("int"); :}
       | FLOAT {: RESULT = new TypeNode("float"); :}
       | BOOL {: RESULT = new TypeNode("boolean"); :}
       | CHAR {: RESULT = new TypeNode("char"); :}
       | STRING {: RESULT = new TypeNode("string"); :};

statement_list ::= statement_list:lista statement:st {: lista.agregarHijo(st); RESULT = lista; :}
                 | statement:st {: Statement_list_node node = new Statement_list_node(); node.agregarHijo(st); RESULT = node; :};


statement ::= var_decl:v {: RESULT = v; :}
            | assignment:a ENDL {: RESULT = a; :}
            | if_statement:i{: RESULT = i; :}
            | loop_statement:l{: RESULT = l; :}
            | for_statement:f{: RESULT = f; :}
            | io_statement:io{: RESULT = io; :}
            | return_statement:r{: RESULT = r; :}
            | break_statement:b {:  RESULT = b; :}
            | expression:e ENDL {: RESULT = e; :}
            /* Manejo de errores */
            | error ENDL {: parser.report_error("Error recuperado en sentencia", null); RESULT = null; :};

var_decl ::= LOCAL type:t IDENTIFIER:id ENDL {: RESULT = new Var_decl_node(t, id); parser.tablaSimbolos.agregar(id, t.getNombreTipo());:}
           | LOCAL type:t IDENTIFIER:id ASSIGN expression:expr ENDL {: RESULT = new Var_decl_node(t, id, expr); parser.tablaSimbolos.agregar(id, t.getNombreTipo()); :}
           | LOCAL type:t IDENTIFIER:id dims_decl:d ENDL {: RESULT = new Var_decl_node(t, id, d, null); parser.tablaSimbolos.agregar(id, t.getNombreTipo()+"[]"); :}
           | LOCAL type:t IDENTIFIER:id dims_decl:d ASSIGN array_init:ai ENDL {: RESULT = new Var_decl_node(t, id, d, ai); parser.tablaSimbolos.agregar(id, t.getNombreTipo()+"[]"); :};

assignment ::= IDENTIFIER:id ASSIGN expression:expr {: RESULT = new Assignment_node(id, expr); :}
            | IDENTIFIER:id dims_decl:d ASSIGN array_init:ai {: RESULT = new Assignment_node(id, d, ai); :};

dims_decl ::= LEFT_ARRAY LIT_INT:i RIGHT_ARRAY LEFT_ARRAY LIT_INT:j RIGHT_ARRAY {: int f = Integer.parseInt(i.toString()); int c = Integer.parseInt(j.toString()); RESULT = new Dims_decl_node(f,c); :};

array_init ::= BLOCK_START row_list:lista BLOCK_END {: RESULT = new Array_init_node(lista); :};

row_list ::= row_list:lista COMMA array_row:ar2 {: lista.agregarHijo(ar2); RESULT = lista; :}
            | array_row:ar {: Row_list_node nuevaLista = new Row_list_node(); nuevaLista.agregarHijo(ar); RESULT = nuevaLista; :};

array_row ::= BLOCK_START expression_list:lista BLOCK_END {: RESULT = new Array_row_node(lista); :};

if_statement ::= DECIDE OF case_list:lista else_part:eBlock END DECIDE ENDL {: RESULT = new If_statement_node(lista, eBlock); :};

case_list ::= case_list:lista single_case:single {: lista.agregarHijo(single); RESULT = lista; :}
            | single_case:single {: Case_list_node node = new Case_list_node(); node.agregarHijo(single); RESULT = node; :};

single_case ::= expression:expr ARROW block:b {: RESULT = new Single_case_node(expr, b); :};

else_part ::= ELSE ARROW block:b {: RESULT = new Else_part_node(b); :}
            | /* vacio */ {: RESULT = new Else_part_node(null); :};

loop_statement ::= LOOP statement_list:lista EXIT WHEN expression:expr ENDL END LOOP ENDL {: RESULT = new Loop_statement_node(lista, expr); :};

for_statement ::= FOR PAREN_OPEN INT assignment:as ENDL expression:expr1 ENDL expression:expr2 PAREN_CLOSE block:b {: RESULT = new For_statement_node(as, expr1, expr2, b); :};

io_statement ::= SHOW expression:expr ENDL {: RESULT = new Io_statement_node(expr); :}
          | GET IDENTIFIER:id ENDL {: RESULT = new Io_statement_node (id); :}
          | GET IDENTIFIER:id dims_decl:d ENDL {: RESULT = new Io_statement_node(id, d); :};

return_statement ::= RETURN expression:expr ENDL {: RESULT = new Return_statement_node(expr); :}
              | RETURN ENDL {: RESULT = new Return_statement_node(); :};

break_statement ::= BREAK ENDL {: RESULT = new Break_statement_node(); :};

func_call ::= IDENTIFIER:id PAREN_OPEN expression_list:lista PAREN_CLOSE {: RESULT = new Func_call_node(id, lista); :};

expression_list ::= expression_list:lista COMMA expression:expr {: lista.agregarHijo(expr); RESULT = lista; :}
                      | expression:expr {: Expression_list_node node = new Expression_list_node(); node.agregarHijo(expr); RESULT = node; :}
                      | /* vacio */ {: RESULT = new Expression_list_node(); :};

expression ::=
             /* --- Operaciones Binarias Aritméticas --- */
               expression:expr1 PLUS expression:expr2
             {: RESULT = new Binary_op_node(expr1, "+", expr2); :}

             | expression:expr1 MINUS expression:expr2
             {: RESULT = new Binary_op_node(expr1, "-", expr2); :}

             | expression:expr1 MULT expression:expr2
             {: RESULT = new Binary_op_node(expr1, "*", expr2); :}

             | expression:expr1 DIV expression:expr2
             {: RESULT = new Binary_op_node(expr1, "/", expr2); :}

             | expression:expr1 DIV_INT expression:expr2
             {: RESULT = new Binary_op_node(expr1, "//", expr2); :}

             | expression:expr1 MOD expression:expr2
             {: RESULT = new Binary_op_node(expr1, "%", expr2); :}

             | expression:expr1 POWER expression:expr2
             {: RESULT = new Binary_op_node(expr1, "^", expr2); :}

             /* --- Operaciones Relacionales --- */
             | expression:expr1 LESS expression:expr2
             {: RESULT = new Binary_op_node(expr1, "<", expr2); :}

             | expression:expr1 GREATER expression:expr2
             {: RESULT = new Binary_op_node(expr1, ">", expr2); :}

             | expression:expr1 LESS_EQ expression:expr2
             {: RESULT = new Binary_op_node(expr1, "<=", expr2); :}

             | expression:expr1 GREATER_EQ expression:expr2
             {: RESULT = new Binary_op_node(expr1, ">=", expr2); :}

             | expression:expr1 EQ_EQ expression:expr2
             {: RESULT = new Binary_op_node(expr1, "==", expr2); :}

             | expression:expr1 NOT_EQ expression:expr2
             {: RESULT = new Binary_op_node(expr1, "!=", expr2); :}

             /* --- Operaciones Lógicas --- */
             | expression:expr1 AND expression:expr2
             {: RESULT = new Binary_op_node(expr1, "AND", expr2); :}

             | expression:expr1 OR expression:expr2
             {: RESULT = new Binary_op_node(expr1, "OR", expr2); :}

             /* --- Unarias Simples --- */
             | NOT expression:expr
             {: RESULT = new Unary_op_node("NOT", expr, "PREFIX"); :}

             | MINUS expression:expr
             {: RESULT = new Unary_op_node("-", expr, "PREFIX"); :} %prec MULT

             /* --- Incrementos y Decrementos (Prefix/Postfix) --- */

             | INC IDENTIFIER:id
             {: RESULT = new Unary_op_node("++", new Id_access_node(id), "PREFIX"); :}

             | DEC IDENTIFIER:id
             {: RESULT = new Unary_op_node("--", new Id_access_node(id), "PREFIX"); :}

             | IDENTIFIER:id INC
             {: RESULT = new Unary_op_node("++", new Id_access_node(id), "POSTFIX"); :}

             | IDENTIFIER:id DEC
             {: RESULT = new Unary_op_node("--", new Id_access_node(id), "POSTFIX"); :}

             /* --- Estructura --- */
             | PAREN_OPEN expression:expr PAREN_CLOSE
             {: RESULT = expr; :}

             | func_call:func
             {: RESULT = func; :}

             | IDENTIFIER:id
             {: RESULT = new Id_access_node(id); :}

             | IDENTIFIER:id dims_decl:dims
             {: RESULT = new Id_access_node(id, dims); :}

             /* --- Literales --- */
             | LIT_INT:val
             {: RESULT = new Literal_node("int", val.toString()); :}

             | LIT_FLOAT:val
             {: RESULT = new Literal_node("float", val.toString()); :}

             | LIT_BOOL:val
             {: RESULT = new Literal_node("boolean", val.toString()); :}

             | LIT_CHAR:val
             {: RESULT = new Literal_node("char", val.toString()); :}

             | LIT_STRING:val
             {: RESULT = new Literal_node("string", val.toString()); :};